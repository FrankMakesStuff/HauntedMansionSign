# HauntedMansionSign
All the code (and some 3D files) for my 3D printed self-updating Haunted Mansion sign!

## About
I'm an electronics geek, a 3D printing geek, and also, a Disney geek... in regards to the theme parks, that is. Specifically, Walt Disney World. And of course, my favorite attraction is... THE HAUNTED MANSION. So I thought, wouldn't it be a cool project if I could make a decorative sign themed in the style of The Haunted Mansion that actually showed the current wait time of the actual attraction in the park?

I initially thought I could just rig up a Python script that would merely do a bit of web-scraping from some website that had the wait-time data available, but it turned out that was easier said than done. A lot, and I mean, a LOT of unofficial WDW websites that CLAIM to have wait times are false - one even clearly shows at the very bottom of the list of rides that the list hasn't been updated for over a year... not exactly my idea of "real time".

I looked to the land of Github to see if anything existed here - lo and behold, there are a couple of modules/libraries that seem to be what I was looking for. My plans were to have a Raspberry Pi communicating serially to an Arduino Nano, so I was hoping for a Python solution. However, the one Python-based library was broken, with the very issue I was experiencing actually in the repository's "issues", completely disregarded for several months now. I did get lucky with [Themeparks, written by Cubehouse](https://github.com/cubehouse/themeparks), which was written in JavaScript - most-likely because the best way to use it would be for a website. The way it works is quite genius: it pretends to be an Android phone running the MyDisneyExperience app to acquire the authentication needed to access the Disney Parks API, containing that precious wait-time data. Well, since it's based in JS, I could put NodeJS on my Pi, but then do I really want to fuss with that to get the rest of the project to work, when I know I could get what I was looking for with Python? So, I used [Naked](https://naked.readthedocs.io/) to handle the JavaScript, and route the output I needed into my Python script.

the Pi, connected to my home Wi-Fi, would pull the wait-time data online. Next, via serial link, communicate with the Nano, which will drive a special brushed DC motor I ripped out of an old discarded inkjet printer that has an optical encoder at the back. I toyed around with some Arduino code, trying to read the signals from the optical sensor. There are actually two sensors in the housing, offset from one another, for the purpose of sensing direction - one sensor will change state before the other, depending on the rotor's direction. The typical Arduino loop() function was way too slow to try and read the sensor while the motor was spinning. Luckily, the Nano (ATMega328P) can perform interrupt operations, so I dedicated the two pins with this capability to read the sensor. I had to be careful, though, since the placeholder for my counter needed to hold a very large number as the motor spun - an unsigned long did the trick. The only caveat is how these microchips handle memory operations with the use of interrupts. The counter needed to exist in volatile memory so that it could be written during the very instant an interrupt gets triggered, but the chip can only work with 8 bits at a time. Anytime I needed to write to the variable was inside the designated interrupt functions, and anytime I needed to read from the variable, I had to disable the interrupts, then enable them again, or else I would get false/corrupt readings, and the whole thing wouldn't work. Everything seems to work now, but every now and again, the motor behaves erratically, and the only thing that can be done is just resetting the Nano.

After some simple math and figuring out gear ratios, I had the Nano controlling the motor quite accurately. I had to make adjustments for a bit of inertia acting on the rotor, which continued to spin ever-so-slightly after switching the motor off. After a few on/off cycles, the whole thing would become completely out of calibration, but luckily my handy interrupt/sensor reading system came to the rescue. The momentum of the rotor caused the sensor interrupts to trigger, and the counter was incremented accordingly. Thus, I was able to compare the interrupt counter against my intended rotation count, and any leftovers were simply subtracted from the next motor operation (i.e., if the rotor overspun 1/8th of a revolution, simply subtract 1/8th of a revolution from the next motor activity, and the whole thing would, in theory, hit the target.)

As for the 3D printed aspect of the project, I had two techniques in mind that I wanted to try. The first, which I'd already experimented with a bit, was taking a paper towel, spraying some gold spraypaint into it, and gently wiping it over the surface of an object printed in black PLA. This gave a really nice antique look. It highlighted all the edges and sharp points, while pushing all the crevices and holes into the "background" - in an artistic manner of putting it - but ultimately giving this elegant, brassy look that had a used, patina look. The other technique involves using two different filaments on one print... with only a single hot-end/nozzle. The object - what I named the "number wheel" - is a large gear printed in black PLA, then white PLA for the numbers. I modeled it and sliced it as a single object, then went into the g-code and manually extracted the upper layers that would essentially print the numbers. I left the lower layers as one g-code file, and pasted in the upper layers into it's own g-code file, and I made sure to copy in the start and end g-code. I do realize that there ARE g-code commands to halt printing for a task like this. Unfortunately, my extremely dangerous, fire-hazard Anet A8 with stock firmware supports neither of these commands, so once I get around to it, I'll set out flashing some new firmware on it... For now, I had to work with what I got...
  
  ## Conclusion
  So! What we have in this repository is the Arduino code that takes the input from the sensor and controls the DC motor, all while taking input via serial connection for external control - either through my laptop for testing, or through the Raspberry Pi for the final product. This Arduino code is quite specific for the task it was written for, but I made sure to comment as often as I could, so that it could also serve as a learning aid of some sort - at the very least, handling serial communication, dealing with interrupts, stuff like that.
  The 3D files include the 123dx project files, which contain both 3D meshes and the 2D sketches they are based on, as well as STL files for everything, and the 2-parts of the Number Wheel model - Print part 1 in one filament coler, switch out a different color, and print part 2 directly on top to get the numbers.
  The JS and Python files interface with the Themeparks and Naked libraries for the ultimate goal of extracting the wait time, in minutes, for The Haunted Mansion in Walt Disney World.
